/*
 * generated by iCampus (JooMDD team) 2.9.1
 */
package de.thm.icampus.joomdd.ejsl.validation
import org.eclipse.xtext.validation.Check
import java.util.HashMap
import java.util.HashSet
import java.util.regex.Pattern
import java.util.Set
import org.eclipse.emf.ecore.EObject
import de.thm.icampus.joomdd.ejsl.eJSL.Author
import de.thm.icampus.joomdd.ejsl.eJSL.BackendSection
import de.thm.icampus.joomdd.ejsl.eJSL.Component
import de.thm.icampus.joomdd.ejsl.eJSL.DynamicPage
import de.thm.icampus.joomdd.ejsl.eJSL.EJSLModel
import de.thm.icampus.joomdd.ejsl.eJSL.EJSLPackage
import de.thm.icampus.joomdd.ejsl.eJSL.Entity
import de.thm.icampus.joomdd.ejsl.eJSL.Extension
import de.thm.icampus.joomdd.ejsl.eJSL.ExtensionPackage
import de.thm.icampus.joomdd.ejsl.eJSL.Language
import de.thm.icampus.joomdd.ejsl.eJSL.Library
import de.thm.icampus.joomdd.ejsl.eJSL.Manifestation
import de.thm.icampus.joomdd.ejsl.eJSL.Section
import de.thm.icampus.joomdd.ejsl.eJSL.Reference
import de.thm.icampus.joomdd.ejsl.eJSL.Page
import de.thm.icampus.joomdd.ejsl.eJSL.CMSExtension
import de.thm.icampus.joomdd.ejsl.eJSL.IndexPage
import java.util.Collections
import java.util.Arrays

//import de.thm.icampus.joomdd.ejsl.eJSL.IndexPage


/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class EJSLValidator extends AbstractEJSLValidator {
	
public static val AMBIGUOUS_ATTRIBUTE_NAME = 'ambiguousAttrName'
	public static val AMBIGUOUS_AUTHOR = 'ambiguousAuthor'
	public static val AMBIGUOUS_CLASS = 'ambiguousClass'
	public static val AMBIGUOUS_DATATYPE = 'ambiguousDatatype'
	public static val AMBIGUOUS_ENTITY = 'ambiguousEntity'
	public static val AMBIGUOUS_EXTENSION = 'ambiguousExt'
	public static val AMBIGUOUS_GLOBALPARAMETER = 'ambiguousGlobalparam'
	public static val AMBIGUOUS_KEY = 'ambiguousKey'
	public static val AMBIGUOUS_LANGUAGE = 'ambiguousLanguage'
	public static val AMBIGUOUS_LOCALPARAMETER = 'ambiguousLocalparam'
	public static val AMBIGUOUS_METHOD = 'ambiguousMethod'
	public static val AMBIGUOUS_PAGE = 'ambiguousPage'
	public static val ENTITY_USED_MULTIPLE_TIMES = 'entityUsedMultipleTimes'
	public static val EXTPACKAGE_CONTAINS_EXTPACKAGE = 'extPackageContainsExtPackage'
	public static val INVALID_AUTHOR_EMAIL = 'invalidAuthorEmail'
	public static val INVALID_AUTHOR_URL = 'invalidAuthorUrl'
	public static val MORE_THAN_ONE_BACKEND = 'moreThanOneBackend'
	public static val MORE_THAN_ONE_FRONTEND = 'moreThanOneFrontend'
	public static val PAGE_USED_MULTIPLE_TIMES = 'pageUsedMultipleTimes'
	public static val MISSING_PRIMARY_ATTRIBUTE = 'missingPrimaryAttribute'
	public static val NOT_PRIMARY_REFERENCE = 'notPrimaryReference'
	public static val AMBIGUOUS_TABLE_COLUMN_ATTRIBUTE = 'ambiguousTableColumnAttribute'
	public static val AMBIGUOUS_FILTER_ATTRIBUTE = 'ambiguousFilterAttribute'
	public static val COLUMNS_USED_MULTIPLE_TIMES = 'columnsUsedMultipleTimes'
	public static val FILTER_USED_MULTIPLE_TIMES = 'filterUsedMultipleTimes'
	public static val MISSING_REFERENCE = 'missingReference'
	public static val FORBIDDEN_UNDERSCORE_PAGENAME = 'forbiddenUnderscorePagename'
	public static val FORBIDDEN_UNDERSCORE_ENTITYNAME = 'forbiddenUnderscoreEntityname'
	public static val FORBIDDEN_UNDERSCORE_EXTENSIONNAME = 'forbiddenUnderscoreExtensionname'
	public static val NO_REFERENCE_TO_MAIN_ENTITY = 'noReferenceToMainEntity'
	public static val MISSING__ATTRIBUTES = 'missingAttributes'
	public static val FORBIDDEN_ENTITYNAME = 'forbiddenEntityname'
	
	/**
	 * A domain consists of one or more domain parts. A domain part may contain
	 * any letter (Unicode), number (0-9) and dash (-) but may not start and
	 * end with a dash (constraint not checked for simplicity). Domain parts
	 * are separated by dot (.).
	 */
	public static val domainPattern = "([\\p{L}0-9-]+\\.)+[\\p{L}0-9]+"

	/**
	 * An e-mail address consists of a user and a domain part which are
	 * separated by an at-sign (@). The user part may contain any letter
	 * (Unicode), number (0-9), dot (.), dash (-), underscore (_) and plus (+).
	 */
	public static val emailPattern = Pattern.compile("[\\p{L}0-9._+-]+?@" + domainPattern)

	/**
	 * An HTTP URL consists of a scheme and a domain. The scheme is limited to
	 * http:// and https://
	 */
	public static val httpUrlPattern = Pattern.compile("https?://" + domainPattern + "(/.*)?")
	
	//int INVALID_NAME
	
	/**
	 * Insert xtext keywords here
	 */
	private static final Set<String> XTEXT_KEYWORDS =
    Collections.unmodifiableSet(
        new HashSet(Arrays.asList('Options', 'Order', 'Keyword', 'first', 'user')));

	/**
	 * Validates if the defined Datatypes of the model have different/unique names
	 */
	@Check
	def checkDatatypesAreUnique(EJSLModel model) {
		var types = new HashSet<String>

		for (type : model.getEjslPart.getDatatypes) {
			if (!types.add(type.name)) {
				error(
					'Datatype must be unique.',
					type,
					EJSLPackage.Literals.DATATYPE__NAME,
					AMBIGUOUS_DATATYPE
				)
			}
		}
	}
	
	/**
	 * Checks if the existing entities of the model have different/unique names
	 */
	@Check
	def checkEntitiesAreUnique(EJSLModel model) {
		var entities = new HashSet<String>

		for (entity : model.getEjslPart.getFeature.getEntities) {
			if (!entities.add(entity.name)) {
				error(
					'Entity names must be unique.',
					entity,
					EJSLPackage.Literals.ENTITY__NAME,
					AMBIGUOUS_ENTITY
				)
			}
		}
	}
	
	/**
	 * Checks if the existing attributes from the available entities have different/unique names
	 */
	@Check
	def checkEntityAttributesAreUnique(Entity entity) {
		var attributes = new HashSet<String>

		for (attribute : entity.attributes) {
			if (!attributes.add(attribute.getName)) {
				error(
					'Attribute names must be unique.',
					attribute,
					EJSLPackage.Literals.ATTRIBUTE__NAME,
					AMBIGUOUS_ATTRIBUTE_NAME
				)
			}
		}
	}
	
	/**
	 * Checks if the existing pages of the model have different/unique names
	 */
	@Check
	def checkPagesAreUnique(EJSLModel model) {
		var pages = new HashSet<String>

		for (page : model.ejslPart.feature.pages) {
			if (!pages.add(page.getName)) {
				error(
					'Page names must be unique.',
					page,
					EJSLPackage.Literals.PAGE__NAME,
					AMBIGUOUS_PAGE
				)
			}
		}
	}
	
	/**
	 * Checks if the existing component conatains max. one backend and one frontend section
	 */
	@Check
	def checkComponentHasOnlyOneSectionInstancePerClass(Component component) {
		var hasBackend = false
		var hasFrontend = false

		var i = 0
		for (Section section : component.sections) {
			if (section instanceof BackendSection) {	// differentiate for backend and frontend section
				if (hasBackend) {
					error(
						'Component must not have more than one backend.',
						EJSLPackage.Literals.COMPONENT__SECTIONS,
						i,
						MORE_THAN_ONE_BACKEND
					)
				}
				hasBackend = true
			} else {
				if (hasFrontend) {
					error(
						'Component must not have more than one frontend.',
						EJSLPackage.Literals.COMPONENT__SECTIONS,
						i,
						MORE_THAN_ONE_FRONTEND
					)
				}
				hasFrontend = true
			}
			i++;
		}
	}

	/**
	 * Checks if the languages of an Extension have different/unique names
	 */
	@Check
	def checkComponentLanguageIsUnique(Extension ext) {
		var langs = new HashSet<String>

		for (lang : ext.languages) {
			if (!langs.add(lang.name)) {
				error(
					'Extension language must be unique.',
					lang,
					EJSLPackage.Literals.LANGUAGE__NAME,
					AMBIGUOUS_LANGUAGE
				)
			}
		}
	}

	/**
	 * Validates the Keys inside of a Language.
	 * Language keys must have different/unique names
	 */
	@Check
	def checkLanguageKeysAreUnique(Language lang) {
		var keys = new HashSet<String>

		for (pair : lang.keyvaluepairs) {
			if (!keys.add(pair.name)) {
				error(
					'Key must be unique.',
					pair,
					EJSLPackage.Literals.KEY_VALUE_PAIR__NAME,
					AMBIGUOUS_KEY
				)
			}
		}
	}

	/**
	 * Checks if the name of an author is used more than once in a manifestation.
	 */
	@Check
	def checkManifestationAuthorsAreUnique(Manifestation manifest) {
		var authors = new HashSet<String>

		for (author : manifest.authors) {
			if (!authors.add(author.name)) {
				warning(
					'Author name is used multiple times.',
					author,
					EJSLPackage.Literals.AUTHOR__NAME,
					AMBIGUOUS_AUTHOR
				)
			}
		}
	}

	/**
	 * Checks if the classes of a library have different/unique names.
	 */
	@Check
	def checkLibraryClassesAreUnique(Library lib) {
		var classes = new HashSet<String>

		for (c : lib.classes) {
			if (!classes.add(c.name)) {
				error(
					'Class name must be unique per library.',
					c,
					EJSLPackage.Literals.CLASS__NAME,
					AMBIGUOUS_CLASS
				)
			}
		}
	}

	/**
	 * Validates if the methods of a class have different/unique names.
	 */
	@Check
	def checkClassMethodsAreUnique(de.thm.icampus.joomdd.ejsl.eJSL.Class c) {
		var methods = new HashSet<String>

		for (method : c.methods) {
			if (!methods.add(method.name)) {
				error(
					'Method name must be unique per class.',
					method,
					EJSLPackage.Literals.METHOD__NAME,
					AMBIGUOUS_METHOD
				)
			}
		}
	}

	/**
	 * Validates if all global parameters of a model have different/unique names.
	 */
	@Check
	def checkPageGlobalparametersAreUnique(EJSLModel model) {
		var params = new HashSet<String>

		for (param : model.getEjslPart.getGlobalparameters) {
			if (!params.add(param.getName)) {
				error(
					'Globalparameter name must be unique.',
					param,
					EJSLPackage.Literals.PARAMETER__NAME,
					AMBIGUOUS_GLOBALPARAMETER
				)
			}
		}
	}

	/**
	 * Check if all local parameters of a page have different/unique names.
	 */
	@Check
	def checkPageLocalparametersAreUnique(Page p) {
		var params = new HashSet<String>

		for (param : p.getLocalparameters) {
			if (!params.add(param.name)) {
				error(
					'Localparameter name must be unique per page.',
					param,
					EJSLPackage.Literals.PARAMETER__NAME,
					AMBIGUOUS_LOCALPARAMETER
				)
			}
		}
	}

	/**
	 * Check if all extensions of a Model have different/unique names.
	 */
	@Check
	def checkExtensionsAreUniquePerClass(CMSExtension cmsExtension) {
		var exts = new HashMap<Class<? extends EObject>, Set<String>>

		for (ext : cmsExtension.extensions) {
			var Class<? extends EObject> type = ext.class
			var Set<String> specializedExts = exts.get(type)
			if (null == specializedExts) {
				specializedExts = new HashSet<String>
				exts.put(type, specializedExts)
			}
			if (!specializedExts.add(ext.name)) {
				error(
					'Extension name must be unique for type ' + ext.class.simpleName + '.',
					ext,
					EJSLPackage.Literals.EXTENSION__NAME,
					AMBIGUOUS_EXTENSION
				)
			}
		}
	}

	/**
	 * Check if the existing extensions don't contain another extensions.
	 */
	@Check
	def checkExtensionPackagesDoNotContainExtensionPackages(ExtensionPackage extPackage) {
		var i = 0
		for (ext : extPackage.extensions) {
			if (ext instanceof ExtensionPackage) {
				error(
					'Extension package must not contain more extension packages.',
					EJSLPackage.Literals.EXTENSION_PACKAGE__EXTENSIONS,
					i,
					EXTPACKAGE_CONTAINS_EXTPACKAGE
				)
			}
			i++
		}
	}

	/**
	 * Validate that an entity can only used once per Page and not multiple times.
	 */
	@Check
	def checkEntitysAreUsedOnlyOncePerPage(DynamicPage page) {
		var entities = new HashSet<String>

		var i = 0
		for (entity : page.getEntities) {
			if (!entities.add(entity.name)) {
				warning(
					'Entity is used multiple times for this page.',
					EJSLPackage.Literals.DYNAMIC_PAGE__ENTITIES,
					i,
					ENTITY_USED_MULTIPLE_TIMES
				)
			}
			i++
		}
	}

	/**
	 * Validate that an entity can only used once per section and not multiple times.
	 */
	@Check
	def checkPagesAreUsedOnlyOncePerSection(Section section) {
		var pages = new HashSet<String>

		var i = 0
		for (page : section.pageRef) {
			if (!pages.add(page.page.name)) {
				warning(
					'Page is used multiple times for this section.',
					EJSLPackage.Literals.PAGE_REFERENCE__PAGESCR,
					i,
					PAGE_USED_MULTIPLE_TIMES
				)
			}
			i++
		}
	}

	/**
	 * Checks if the author uses a valid email adress
	 */	
	@Check
	def checkAuthorEmailIsValid(Author author) {
		if (!author.authoremail.isEmailAdressValid) {
			error(
				'Invalid e-mail address. Should be in this format: xxx@xx.xx',
				EJSLPackage.Literals.AUTHOR__AUTHOREMAIL,
				INVALID_AUTHOR_EMAIL
			)
		}
	}

	/**
	 * Checks if the author uses a valid url
	 */	
	@Check
	def checkAuthorUrlIsValid(Author author) {
		if (!author.authorurl.isUrlValid) {
			warning(
				'Invalid URL. Should be in this format: http(s)//:www.xxx.xx',
				EJSLPackage.Literals.AUTHOR__AUTHORURL,
				INVALID_AUTHOR_URL
			)
		}
	}

	/**
	 * Method for email matching
	 */	
	def isEmailAdressValid(String address) {
		return emailPattern.matcher(address).matches
	}
	
	/**
	 * Method for url matching
	 */	
	def isUrlValid(String url) {
		return httpUrlPattern.matcher(url).matches
	}
	
	/**
	 * Checks if entity has attributes
	 */
	@Check
	def checkEntityHasAttributes(Entity entity) {
		if (entity.attributes.size == 0 || entity.attributes == null) {
			error(
					'Entity must have attributes with at least one attribute in it.',
					entity,
					EJSLPackage.Literals.ENTITY__NAME,
					MISSING__ATTRIBUTES
				)
		}
	}
		
	/**
	 * Checks if at least one Primary attribute exists in the attributes of an entity
	 */	
	@Check
	def checkPrimaryAttributeExist(Entity entity) {
		var hasPrimary = false;
		
		if (entity.attributes.size != 0) {
			for (attribute : entity.attributes) {
			if(attribute.isunique){
				hasPrimary = true;
			}
		}
		if(!hasPrimary){	// if no primary attribute is found
			error(
					'Attributes must have a primary attribute.',
					entity.attributes.get(0),
					EJSLPackage.Literals.ATTRIBUTE__NAME,
					MISSING_PRIMARY_ATTRIBUTE
				)
		}
		}	
	}
		
	/**
	 * Validates if the reference to an attribute leads on a primary attribtue
	 */	
	@Check
	def refToAttributeMustBePrimary(Reference reference){
		for (attribute : reference.attributerefereced) {
			if(!attribute.isunique && !attribute.isprimary){
				error(
					'The referenced attribute has to be a unique attribute.',
					reference,
					EJSLPackage.Literals.REFERENCE__ATTRIBUTEREFERECED,
					NOT_PRIMARY_REFERENCE
				)
			}
		}
	}
		
	/**
	 * Checks if the name of an attribute fulfills certain conventions.
	 * The name can't be id, ordering, state, checked_out_time, created_by and checked_out
	 */	
	@Check
	def checkAttributename(Entity entity) {
		for (attribute : entity.attributes) {			
//			if (attribute.name == "id") {				
//				error(
//					'\"id\" is not a valid attribute name!',
//					attribute,
//					EJSLPackage.Literals.ATTRIBUTE__NAME,
//					AMBIGUOUS_ATTRIBUTE_NAME
//				)
//			}			
			if(attribute.name == "ordering"||attribute.name =="state"||attribute.name =="checked_out" ||
				attribute.name == "checked_out_time" ||attribute.name == "created_by"){ 				
				warning("Attribute name should not be: " + attribute.name +"!",
					attribute,
					EJSLPackage.Literals.ATTRIBUTE__NAME,
					AMBIGUOUS_ATTRIBUTE_NAME
				)				
			}
		}
	}
	
	/**
	 * Check if the entity in the filter is declared in the page
 	*/
	@Check
    def nonDeclaredFilterAttribute(DynamicPage p){ 
        for(filt : p.filters){
            val enti = filt.eContainer as Entity
            if(!p.entities.contains(enti)){
                error(
                        'Entity for the filter attribute must be declared before.',
                        p,
                        EJSLPackage.Literals.DYNAMIC_PAGE__FILTERS.EOpposite,
                        AMBIGUOUS_FILTER_ATTRIBUTE
                    )
            }
        }
    }

	/**
	 * Check if the entity in the table column is declared in the page
 	*/
    @Check
    def nonDeclaredColumnAttribute(DynamicPage p){   
        for(column : p.tablecolumns){
            val enti = column.eContainer as Entity
            if(!p.entities.contains(enti)){
                error(
                        'Entity for the table column attribute must be declared before.',
                        p,
                        EJSLPackage.Literals.DYNAMIC_PAGE__TABLECOLUMNS.EOpposite,
                        AMBIGUOUS_TABLE_COLUMN_ATTRIBUTE
                    )
            }
        }
    }

	/**
	 * Check table column are only once in a page
	 */
	@Check
	def checkTableColumnsAreUnique(DynamicPage p){
		var enticolumns = new HashSet<String>
		for (column : p.tablecolumns){
			val enti = column.eContainer as Entity	
			if (!enticolumns.add(enti.name+column.name)) {
				error(
                        'table column used multiple times in this Page.',
                        p,
                        EJSLPackage.Literals.DYNAMIC_PAGE__TABLECOLUMNS.EOpposite,
                        COLUMNS_USED_MULTIPLE_TIMES
                    )
			}	
		}
	}
	
	/**
	 * Check Filters are only once in a page
	 */
	@Check
	def checkFiltersAreUnique(DynamicPage p){
		var entifilters = new HashSet<String>
		for (filter : p.filters){
			val enti = filter.eContainer as Entity	
			if (!entifilters.add(enti.name+filter.name)) {
				error(
                        'Filter used multiple times in this Page!',
                        p,
                        EJSLPackage.Literals.DYNAMIC_PAGE__FILTERS.EOpposite,
                        FILTER_USED_MULTIPLE_TIMES
                    )
			}	
		}
	}
		
	/**
	 * Check Entity with other Entity as Attribute has a Reference to it
	 */
	@Check
	def checkAttributeReferenceToEntity(EJSLModel model){
		var entities = new HashSet<String>
		var refs = new HashSet<String>
		
		// Save all Entity names
		for (entity : model.getEjslPart.getFeature.getEntities) {
			entities.add(entity.name)
		}
		
		// Run through all Entities
		for (entity : model.getEjslPart.getFeature.getEntities) {
			
			// Run through all attributes of that Entity
			for (attribute : entity.attributes) {
				
				// Check for every attribute if there is a equal named Entity
				for (eName : entities) {
					
					if (attribute.name.toLowerCase == eName.toLowerCase) {			
						
						// Check if Reference exists
						for (references : entity.references){
							refs.add(references.entity.name.toLowerCase)
						}
						
						// When no Reference to that Entity exists, show a warning message
						if (refs.add(eName.toLowerCase)) {
							warning(
								'Attribute ' + attribute.name + ' should have a Reference to matching Entity. Make sure referenced Entity is defined above',
								attribute,
								EJSLPackage.Literals.ATTRIBUTE__NAME,
								MISSING_REFERENCE
							)
						}
					}
					
					// Reset references
					refs.clear
				}
			}
		}
	}
	
	/**
	 * Checks if the name of a page contains a underscore
	 */
	@Check
	def checkNoUnderscoreInPageName(EJSLModel model) {
		for (page : model.ejslPart.getFeature.pages) {
			if (page.name.contains('_')) {
				error(
					'Page name ' + page.name + ' contains a underscore',
								page,
								EJSLPackage.Literals.PAGE__NAME,
								FORBIDDEN_UNDERSCORE_PAGENAME
				)
			}
		}
	}
	
	/**
	 * Checks if the name of a entity contains a underscore
	 */
	@Check
	def checkNoUnderscoreInEntityName(EJSLModel model) {
		for (entity : model.getEjslPart.getFeature.getEntities) {
			if (entity.name.contains('_')) {
				error(
					'Entity name ' + entity.name + ' contains a underscore',
								entity,
								EJSLPackage.Literals.ENTITY__NAME,
								FORBIDDEN_UNDERSCORE_ENTITYNAME
				)
			}
		}
	}
	
	/**
	 * Checks if the name of a extension contains a underscore
	 */
	@Check
	def checkNoUnderscoreInExtensionName(Extension ext) {
		if (ext.name.contains('_')) {
			error(
					'Extension name ' + ext.name + ' contains a underscore',
								ext,
								EJSLPackage.Literals.EXTENSION__NAME,
								FORBIDDEN_UNDERSCORE_EXTENSIONNAME
				)
		}
	}
	
	/**
	 * Check if entities that occur in index pages with further entities, have a reference to the first entity
	 */
	@Check
	def checkMultipleEntitiesInIndexPageReferences(EJSLModel model) {
		var mainEntities = new HashSet<Entity>
		var foundReferenceEntity = new HashSet<Entity>
		
		for (page: model.ejslPart.feature.pages) {
			
			if (page instanceof IndexPage){
				
				if (page.entities.size > 1) {
					
					// Save main entity
					mainEntities.add(page.entities.get(0))
					for (int i : 1 ..< page.entities.size) {
						
						// Check if current entity has a reference to main entity
						for (referencedE : page.entities.get(i).references) {
							
							if ((referencedE.entity as Entity).name.toLowerCase == mainEntities.get(0).name.toLowerCase) {
								foundReferenceEntity.add(referencedE.entity as Entity)
							}
						}
						if (foundReferenceEntity.empty) {
							error(
								'Entity: \'' + page.entities.get(i).name + 
								'\' of IndexPage: \'' + page.name + '\' has no reference to IndexPage main-entity: \'' + 
								mainEntities.get(0).name + '\'.',
								page,
								EJSLPackage.Literals.DYNAMIC_PAGE__ENTITIES,
								i,
								NO_REFERENCE_TO_MAIN_ENTITY
							)
						}
						foundReferenceEntity.clear
					}
				}
				mainEntities.clear
			}
		}
	}
	
	/**
	 * Check entity name does not match a Xtext keyword
	 * TODO make this work, xtext validation runs before this validation...
	 */
	@Check(FAST)
	def checkEntityNameIsNoXtextKeyword(EJSLModel model) {
		for (entity : model.ejslPart.feature.entities) {
			if (XTEXT_KEYWORDS.contains(entity.name)){
				error(
					'Entity name ' + entity.name + ' is a Xtext keyword.',
								entity,
								EJSLPackage.Literals.ENTITY__NAME,
								FORBIDDEN_ENTITYNAME
				)
			}
		}
	}
}
