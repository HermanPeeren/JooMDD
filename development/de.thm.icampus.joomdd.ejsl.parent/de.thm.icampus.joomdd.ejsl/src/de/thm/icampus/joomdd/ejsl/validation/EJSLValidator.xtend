/*
 * generated by iCampus (JooMDD team) 2.9.1
 */
package de.thm.icampus.joomdd.ejsl.validation

import de.thm.icampus.joomdd.ejsl.eJSL.CMSExtension
import de.thm.icampus.joomdd.ejsl.eJSL.EJSLModel
import de.thm.icampus.joomdd.ejsl.eJSL.EJSLPackage
import de.thm.icampus.joomdd.ejsl.eJSL.Extension
import de.thm.icampus.joomdd.ejsl.eJSL.ExtensionPackage
import de.thm.icampus.joomdd.ejsl.eJSL.Language
import de.thm.icampus.joomdd.ejsl.eJSL.Library
import de.thm.icampus.joomdd.ejsl.validation.elements.EntityValidator
import de.thm.icampus.joomdd.ejsl.validation.elements.ManifestValidator
import de.thm.icampus.joomdd.ejsl.validation.elements.PageValidator
import de.thm.icampus.joomdd.ejsl.validation.elements.SectionValidator 
import java.util.HashMap
import java.util.HashSet
import java.util.Set
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.validation.ComposedChecks

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@ComposedChecks(validators = #[EntityValidator, PageValidator, ManifestValidator, SectionValidator])
class EJSLValidator extends AbstractEJSLValidator {
	
	public static val AMBIGUOUS_CLASS = 'ambiguousClass'
	public static val AMBIGUOUS_DATATYPE = 'ambiguousDatatype'
	public static val AMBIGUOUS_EXTENSION = 'ambiguousExt'
	public static val AMBIGUOUS_KEY = 'ambiguousKey'
	public static val AMBIGUOUS_LANGUAGE = 'ambiguousLanguage'
	public static val AMBIGUOUS_METHOD = 'ambiguousMethod'
	public static val EXTPACKAGE_CONTAINS_EXTPACKAGE = 'extPackageContainsExtPackage'
	public static val FORBIDDEN_UNDERSCORE_EXTENSIONNAME = 'forbiddenUnderscoreExtensionname'
	

	/**
	 * Validates if the defined Datatypes of the model have different/unique names
	 */
	@Check
	def checkDatatypesAreUnique(EJSLModel model) {
		var types = new HashSet<String>

		for (type : model.getEjslPart.getDatatypes) {
			if (!types.add(type.name)) {
				error(
					'Datatype must be unique.',
					type,
					EJSLPackage.Literals.DATATYPE__NAME,
					AMBIGUOUS_DATATYPE
				)
			}
		}
	}

	/**
	 * Checks if the languages of an Extension have different/unique names
	 */
//	@Check
//	def checkComponentLanguageIsUnique(Extension ext) {
//		var langs = new HashSet<String>
//
//		for (lang : ext.languages) {
//			if (!langs.add(lang.name)) {
//				error(
//					'Extension language must be unique.',
//					lang,
//					EJSLPackage.Literals.LANGUAGE__NAME,
//					AMBIGUOUS_LANGUAGE
//				)
//			}
//		}
//	}

	/**
	 * Validates the Keys inside of a Language.
	 * Language keys must have different/unique names
	 */
	@Check
	def checkLanguageKeysAreUnique(Language lang) {
		var keys = new HashSet<String>

		for (pair : lang.keyvaluepairs) {
			if (!keys.add(pair.name)) {
				error(
					'Key must be unique.',
					pair,
					EJSLPackage.Literals.KEY_VALUE_PAIR__NAME,
					AMBIGUOUS_KEY
				)
			}
		}
	}

	/**
	 * Checks if the classes of a library have different/unique names.
	 */
	@Check
	def checkLibraryClassesAreUnique(Library lib) {
		var classes = new HashSet<String>

		for (c : lib.classes) {
			if (!classes.add(c.name)) {
				error(
					'Class name must be unique per library.',
					c,
					EJSLPackage.Literals.CLASS__NAME,
					AMBIGUOUS_CLASS
				)
			}
		}
	}

	/**
	 * Validates if the methods of a class have different/unique names.
	 */
	@Check
	def checkClassMethodsAreUnique(de.thm.icampus.joomdd.ejsl.eJSL.Class c) {
		var methods = new HashSet<String>

		for (method : c.methods) {
			if (!methods.add(method.name)) {
				error(
					'Method name must be unique per class.',
					method,
					EJSLPackage.Literals.METHOD__NAME,
					AMBIGUOUS_METHOD
				)
			}
		}
	}

	/**
	 * Check if all extensions of a Model have different/unique names.
	 */
	@Check
	def checkExtensionsAreUniquePerClass(CMSExtension cmsExtension) {
		var exts = new HashMap<Class<? extends EObject>, Set<String>>

		for (ext : cmsExtension.extensions) {
			var Class<? extends EObject> type = ext.class
			var Set<String> specializedExts = exts.get(type)
			if (null == specializedExts) {
				specializedExts = new HashSet<String>
				exts.put(type, specializedExts)
			}
			if (!specializedExts.add(ext.name)) {
				error(
					'Extension name must be unique for type ' + ext.class.simpleName + '.',
					ext,
					EJSLPackage.Literals.EXTENSION__NAME,
					AMBIGUOUS_EXTENSION
				)
			}
		}
	}

	/**
	 * Check if the existing extensions don't contain another extensions.
	 */
	@Check
	def checkExtensionPackagesDoNotContainExtensionPackages(ExtensionPackage extPackage) {
		var i = 0
		for (ext : extPackage.extensions) {
			if (ext instanceof ExtensionPackage) {
				error(
					'Extension package must not contain more extension packages.',
					EJSLPackage.Literals.EXTENSION_PACKAGE__EXTENSIONS,
					i,
					EXTPACKAGE_CONTAINS_EXTPACKAGE
				)
			}
			i++
		}
	}
	
//	/**
//	 * Checks if the name of a extension contains a underscore
//	 */
//	@Check
//	def checkNoUnderscoreInExtensionName(Extension ext) {
//		if (ext.name.contains('_')) {
//			error(
//					'Extension name ' + ext.name + ' contains a underscore',
//								ext,
//								EJSLPackage.Literals.EXTENSION__NAME,
//								FORBIDDEN_UNDERSCORE_EXTENSIONNAME
//				)
//		}
//	}
}
